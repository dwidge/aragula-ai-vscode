<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Ask AI</title>
    <style>
      :root {
        --background-color: #f4f4f4;
        --text-color: #000;
        --textarea-background: #fff;
        --textarea-border: #ccc;
        --button-background: #007acc;
        --button-hover: #005fa3;
        --pre-background: #e0e0e0;
        --pre-border: #ccc;
        --user-message-background: #e0f7fa;
        --assistant-message-background: #f0f0f0;
        --system-message-background: #f8e6ff;
        --prompt-message-background: #f8e6ff;
        --log-message-background: #e0e0e0;
        --error-message-background: #ffe0b2;
        --warning-message-background: #fff9c4;
        --info-message-background: #bbdefb;
        --loading-message-background: #e8f5e9;
        --file-button-background: #ddd;
        --file-button-hover: #ccc;
        --file-button-remove-hover: #f44336;
        --file-button-text-color: #000;
        --prompts-header-background: #ddd;
        --prompts-header-hover: #ccc;
        --prompt-item-background: #eee;
        --prompt-item-hover: #ddd;
        --prompt-delete-button-hover: #f44336;
        --popup-background: var(--background-color);
        --popup-border: var(--pre-border);
        --popup-shadow: 0 4px 8px rgba(0, 0, 0, 0.1);
        --tool-button-background: var(--file-button-background);
        --tool-button-hover: var(--tool-button-hover);
        --tool-button-remove-hover: var(--tool-button-remove-hover);
        --tool-button-text-color: var(--tool-button-text-color);
        --provider-button-background: var(--file-button-background);
        --provider-button-hover: var(--provider-button-hover);
        --provider-button-remove-hover: var(--provider-button-remove-hover);
        --provider-button-text-color: var(--provider-button-text-color);
        --form-input-background: var(--textarea-background);
        --form-input-border: var(--textarea-border);
        --form-input-text-color: var(--text-color);
        --plan-step-background: #e0f2f7;
        --plan-step-completed-background: #c8e6c9;
        --plan-step-executing-background: #fff9c4;
        --plan-step-failed-background: #ffcdd2;
        --plan-step-border: #b2ebf2;
        --plan-step-completed-border: #a5d6a7;
        --plan-step-executing-border: #ffe082;
        --plan-step-failed-border: #ef9a9a;
        --plan-step-message-background: #f0f4f6;
        --plan-step-message-border: #cce7ee;
        --progress-bar-background: #ccc;
        --progress-bar-fill: #4caf50;
        --cancel-button-color: #f44336;
        --cancel-button-hover-color: #d32f2f;
      }
      @media (prefers-color-scheme: dark) {
        :root {
          --background-color: #1e1e1e;
          --text-color: #ccc;
          --textarea-background: #252526;
          --textarea-border: #555;
          --button-background: #007acc;
          --button-hover: #005fa3;
          --pre-background: #252526;
          --pre-border: #555;
          --user-message-background: #2a3c42;
          --assistant-message-background: #333333;
          --system-message-background: #4a2d57;
          --prompt-message-background: #4a2d57;
          --log-message-background: #333333;
          --error-message-background: #572c0f;
          --warning-message-background: #554d00;
          --info-message-background: #2a3c42;
          --loading-message-background: #1e3628;
          --file-button-background: #555;
          --file-button-hover: #666;
          --file-button-remove-hover: #e57373;
          --file-button-text-color: #eee;
          --prompts-header-background: #555;
          --prompts-header-hover: #666;
          --prompt-item-background: #444;
          --prompt-item-hover: #555;
          --prompt-delete-button-hover: #e57373;
          --popup-background: var(--background-color);
          --popup-border: var(--pre-border);
          --popup-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
          --tool-button-background: var(--file-button-background);
          --tool-button-hover: var(--tool-button-hover);
          --tool-button-remove-hover: var(--tool-button-remove-hover);
          --tool-button-text-color: var(--tool-button-text-color);
          --provider-button-background: var(--file-button-background);
          --provider-button-hover: var(--provider-button-hover);
          --provider-button-remove-hover: var(--provider-button-remove-hover);
          --provider-button-text-color: var(--provider-button-text-color);
          --form-input-background: var(--textarea-background);
          --form-input-border: var(--textarea-border);
          --form-input-text-color: var(--text-color);
          --plan-step-background: #263238;
          --plan-step-completed-background: #33691e;
          --plan-step-executing-background: #f57f17;
          --plan-step-failed-background: #b71c1c;
          --plan-step-border: #37474f;
          --plan-step-completed-border: #558b2f;
          --plan-step-executing-border: #fbc02d;
          --plan-step-failed-border: #c62828;
          --plan-step-message-background: #37474f;
          --plan-step-message-border: #455a64;
          --progress-bar-background: #555;
          --progress-bar-fill: #4caf50;
          --cancel-button-color: #e57373;
          --cancel-button-hover-color: #ef9a9a;
        }
      }
      body {
        font-family: Arial, sans-serif;
        margin: 0;
        padding: 20px;
        background-color: var(--background-color);
        color: var(--text-color);
      }
      #selected-files-container,
      #enabled-tools-container,
      #selected-provider-container {
        display: flex;
        gap: 5px;
        margin-bottom: 10px;
        flex-wrap: wrap;
      }
      .file-button,
      .tool-button,
      .provider-button {
        background-color: var(--provider-button-background);
        color: var(--provider-button-text-color);
        border: none;
        padding: 5px 10px;
        border-radius: 5px;
        display: flex;
        align-items: center;
        gap: 5px;
        font-size: 0.9em;
      }
      .file-button:hover,
      .tool-button:hover,
      .provider-button:hover {
        background-color: var(--provider-button-hover);
      }
      .file-button .remove-file-button,
      .tool-button .remove-tool-button,
      .provider-button .remove-provider-button {
        background: none;
        border: none;
        color: var(--provider-button-text-color);
        cursor: pointer;
        padding: 0 5px;
        border-radius: 3px;
        font-size: 1em;
        line-height: 1;
        display: flex;
        align-items: center;
        justify-content: center;
        width: 18px;
        height: 18px;
      }

      .file-button .remove-file-button:hover,
      .tool-button .remove-tool-button:hover,
      .provider-button .remove-provider-button:hover {
        color: white;
        background-color: var(--provider-button-remove-hover);
      }
      .input-area {
        display: flex;
        flex-direction: column;
        gap: 10px;
      }
      .input-row {
        display: flex;
        gap: 10px;
        align-items: flex-start;
        position: relative;
      }
      textarea,
      .form-input,
      select {
        box-sizing: border-box;
        width: 100%;
        padding: 10px;
        border-radius: 5px;
        border: 1px solid var(--form-input-border);
        background-color: var(--form-input-background);
        color: var(--form-input-text-color);
        resize: vertical;
      }
      .prompt-buttons {
        display: flex;
        flex-direction: column;
        gap: 5px;
        align-self: stretch;
      }
      .prompt-buttons button {
        flex-grow: 1;
        padding: 8px 10px;
        font-size: 0.9em;
      }
      .button-row {
        display: flex;
        gap: 10px;
        flex-wrap: wrap;
      }
      button {
        padding: 10px 15px;
        border: none;
        background-color: var(--button-background);
        color: white;
        border-radius: 5px;
        cursor: pointer;
      }
      button:hover:not(:disabled) {
        background-color: var(--button-hover);
      }
      pre {
        background-color: var(--pre-background);
        border-radius: 5px;
        border: 1px solid var(--pre-border);
        white-space: pre-wrap;
        color: var(--text-color);
        overflow-x: auto;
        position: relative;
        display: flex;
        flex-direction: column;
      }

      .message-content-wrapper {
        padding: 8px;
        display: flex;
        flex-direction: column;
        flex-grow: 1;
        gap: 8px;
      }

      .message-header {
        display: grid;
        grid-template-columns: 1fr auto auto auto;
        align-items: start;
        cursor: pointer;
        position: relative;
      }
      .message-header.non-collapsible {
        cursor: default;
      }
      .message-preview {
        overflow: hidden;
        text-overflow: ellipsis;
        white-space: nowrap;
        margin-right: 10px;
      }
      .message-type-badge {
        padding: 2px 5px;
        border-radius: 3px;
        font-size: 0.7em;
        background-color: rgba(0, 0, 0, 0.2);
        color: white;
        margin-left: auto;
      }
      .collapse-button,
      .cancel-button {
        background: none;
        border: none;
        color: var(--text-color);
        cursor: pointer;
        font-size: 0.8em;
        opacity: 0.5;
        padding: 0 5px;
        margin-left: 5px;
      }
      .cancel-button {
        color: var(--cancel-button-color);
      }
      .collapse-button:hover,
      .cancel-button:hover {
        opacity: 1;
      }
      .cancel-button:hover {
        color: var(--cancel-button-hover-color);
      }

      .message {
        word-wrap: break-word;
        display: flex;
        flex-direction: column;
        gap: 8px;
      }

      .message-body-content {
        padding-top: 8px;
        border-top: 1px dashed var(--pre-border);
      }

      .collapsible-content {
        overflow: hidden;
        transition: max-height 0.3s ease-out;
      }
      .collapsible-content.collapsed {
        max-height: 0;
        padding-top: 0;
        padding-bottom: 0;
        margin-bottom: 0;
        overflow: hidden;
      }

      #messages-container {
        display: flex;
        flex-direction: column;
        gap: 8px;
      }

      .user-message {
        background-color: var(--user-message-background);
      }
      .assistant-message {
        background-color: var(--assistant-message-background);
      }
      .system-message {
        background-color: var(--system-message-background);
      }
      .prompt-message {
        background-color: var(--prompt-message-background);
      }
      .tool-message {
        background-color: var(--prompt-message-background);
      }
      .log-message {
        background-color: var(--log-message-background);
      }
      .error-message {
        background-color: var(--error-message-background);
      }
      .warning-message {
        background-color: var(--warning-message-background);
      }
      .info-message {
        background-color: var(--info-message-background);
      }
      .loading-message {
        background-color: var(--loading-message-background);
      }
      .loader {
        width: 20px;
        height: 20px;
        border: 3px solid white;
        border-top: 3px solid transparent;
        border-radius: 50%;
        animation: spin 1s linear infinite;
        display: inline-block;
      }
      @keyframes spin {
        0% {
          transform: rotate(0deg);
        }
        100% {
          transform: rotate(360deg);
        }
      }

      .prompts-section {
        margin-bottom: 15px;
      }
      .prompts-header {
        background-color: var(--prompts-header-background);
        padding: 10px;
        border-radius: 5px 5px 0 0;
        cursor: pointer;
        display: flex;
        justify-content: space-between;
        align-items: center;
      }
      .prompts-header:hover {
        background-color: var(--prompts-header-hover);
      }
      .prompts-list {
        list-style: none;
        padding: 0;
        margin: 0;
        border: 1px solid var(--pre-border);
        border-top: none;
        border-radius: 0 0 5px 5px;
        overflow: hidden;
      }
      .prompt-item {
        background-color: var(--prompt-item-background);
        padding: 10px;
        border-bottom: 1px solid var(--pre-border);
        display: flex;
        justify-content: space-between;
        align-items: flex-start;
        cursor: pointer;
        word-wrap: break-word;
        white-space: normal;
      }
      .prompt-item:last-child {
        border-bottom: none;
      }
      .prompt-item:hover {
        background-color: var(--prompt-item-hover);
      }
      .prompt-delete-button {
        background: none;
        border: none;
        color: var(--file-button-text-color);
        cursor: pointer;
        padding: 0 5px;
        border-radius: 3px;
        font-size: 0.8em;
        line-height: 1;
        width: 20px;
        height: 20px;
        display: inline-flex;
        align-items: center;
        justify-content: center;
      }
      .prompt-delete-button:hover {
        color: white;
        background-color: var(--prompt-delete-button-hover);
      }
      .prompt-text {
        flex-grow: 1;
        margin-right: 10px;
        word-wrap: break-word;
      }

      .prompt-popup,
      .tool-popup,
      .provider-popup {
        position: fixed;
        z-index: 10;
        background-color: var(--popup-background);
        border: 1px solid var(--popup-border);
        border-radius: 5px;
        box-shadow: var(--popup-shadow);
        padding: 10px;
        display: none;
        top: 0;
        right: 0;
        max-height: 300px;
        overflow-y: auto;
        max-width: 80vw;
      }
      .prompt-popup .prompts-list,
      .tool-popup .tool-list,
      .provider-popup .provider-list {
        border: none;
        overflow-y: auto;
        max-height: unset;
      }
      .tool-popup .tool-list .tool-item {
        background-color: var(--prompt-item-background);
        padding: 10px;
        border-bottom: 1px solid var(--pre-border);
        display: flex;
        justify-content: space-between;
        align-items: flex-start;
        cursor: pointer;
        word-wrap: break-word;
        white-space: normal;
      }
      .tool-popup .tool-list .tool-item:last-child {
        border-bottom: none;
      }
      .tool-popup .tool-list .tool-item:hover {
        background-color: var(--prompt-item-hover);
      }
      .provider-popup .provider-list .provider-item {
        background-color: var(--prompt-item-background);
        padding: 10px;
        border-bottom: 1px solid var(--pre-border);
        display: flex;
        justify-content: space-between;
        align-items: flex-start;
        cursor: pointer;
        word-wrap: break-word;
        white-space: normal;
      }
      .provider-popup .provider-list .provider-item:last-child {
        border-bottom: none;
      }
      .provider-popup .provider-list .provider-item:hover {
        background-color: var(--prompt-item-hover);
      }

      .provider-popup-header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        margin-bottom: 10px;
      }
      .provider-popup-header button {
        display: none;
      }
      .provider-form {
        display: flex;
        flex-direction: column;
        gap: 10px;
        margin-top: 10px;
      }
      .provider-form label {
        margin-bottom: 5px;
        font-weight: bold;
      }
      .provider-form input {
        margin-bottom: 0;
        padding: 8px;
        border-radius: 5px;
        border: 1px solid var(--form-input-border);
        background-color: var(--form-input-background);
        color: var(--form-input-text-color);
      }
      .provider-form select {
        margin-bottom: 0;
        padding: 8px;
        border-radius: 5px;
        border: 1px solid var(--form-input-border);
        background-color: var(--form-input-background);
        color: var(--form-input-text-color);
        appearance: none;
        -webkit-appearance: none;
        background-image: url('data:image/svg+xml;utf8,<svg fill="black" height="24" viewBox="0 0 24 24" width="24" xmlns="http://www.w3.org/2000/svg"><path d="M7 10l5 5 5-5z"/><path d="0 0h24v24H0z" fill="none"/></svg>');
        background-repeat: no-repeat;
        background-position-x: 100%;
        background-position-y: 5px;
        padding-right: 30px;
      }
      @media (prefers-color-scheme: dark) {
        .provider-form select {
          background-image: url('data:image/svg+xml;utf8,<svg fill="white" height="24" viewBox="0 0 24 24" width="24" xmlns="http://www.w3.org/2000/svg"><path d="M7 10l5 5 5-5z"/><path d="0 0h24v24H0z" fill="none"/></svg>');
        }
      }

      .provider-form-buttons {
        display: flex;
        gap: 10px;
        justify-content: flex-end;
        margin-top: 10px;
      }
      .error-message-inline {
        color: red;
        font-size: 0.8em;
        margin-top: 2px;
        display: none;
      }
      .select-provider-button,
      .duplicate-provider-button {
        background: none;
        border: none;
        color: var(--file-button-text-color);
        cursor: pointer;
        padding: 0 5px;
        border-radius: 3px;
        font-size: 0.8em;
        line-height: 1;
        width: 20px;
        height: 20px;
        display: inline-flex;
        align-items: center;
        justify-content: center;
      }
      .select-provider-button:hover,
      .duplicate-provider-button:hover {
        color: white;
        background-color: var(--button-background);
      }

      .auto-checkbox {
        display: flex;
        align-items: center;
        gap: 5px;
        font-size: 0.9em;
      }
      .auto-checkbox input[type="checkbox"] {
        margin: 0;
      }

      #plan-container {
        margin-top: 20px;
        padding: 10px;
        border: 1px solid var(--pre-border);
        border-radius: 5px;
        background-color: var(--pre-background);
        display: none;
      }
      #plan-container h3 {
        margin-top: 0;
        margin-bottom: 10px;
        border-bottom: 1px solid var(--pre-border);
        padding-bottom: 5px;
      }
      .plan-step {
        padding: 10px;
        margin-bottom: 8px;
        border-radius: 5px;
        border: 1px solid var(--plan-step-border);
        background-color: var(--plan-step-background);
        display: flex;
        flex-direction: column;
      }
      .plan-step-header {
        display: grid;
        grid-template-columns: auto 1fr auto;
        align-items: center;
        gap: 10px;
        cursor: pointer;
      }
      .plan-step-status {
        font-size: 1.2em;
        min-width: 20px;
        text-align: center;
      }
      .plan-step-preview {
        overflow: hidden;
        text-overflow: ellipsis;
        white-space: nowrap;
      }
      .plan-step-content {
        overflow: hidden;
        transition: max-height 0.3s ease-out;
        display: flex;
        flex-direction: column;
        gap: 8px;
      }
      .plan-step-content.collapsed {
        max-height: 0;
        padding-top: 0;
        padding-bottom: 0;
        margin-bottom: 0;
        overflow: hidden;
      }
      .plan-step-content p {
        margin-top: 0;
        margin-bottom: 5px;
        font-weight: bold;
      }
      .plan-step-content pre {
        margin-top: 0;
        padding: 8px;
      }
      .plan-step:has(.plan-step-content.collapsed) .plan-step-content strong {
        display: none;
      }

      .plan-step.completed {
        background-color: var(--plan-step-completed-background);
        border-color: var(--plan-step-completed-border);
      }
      .plan-step.executing {
        background-color: var(--plan-step-executing-background);
        border-color: var(--plan-step-executing-border);
      }
      .plan-step.failed {
        background-color: var(--plan-step-failed-background);
        border-color: var(--plan-step-failed-border);
      }
      #plan-controls {
        margin-top: 10px;
        display: flex;
        gap: 10px;
        flex-wrap: wrap;
        justify-content: center;
      }
      #plan-error {
        color: red;
        margin-top: 10px;
        font-weight: bold;
        display: none;
      }

      .step-messages-container {
        padding-top: 8px;
        border-top: 1px dashed var(--pre-border);
        display: flex;
        flex-direction: column;
        gap: 8px;
      }
      .step-messages-container .message {
        background-color: var(--plan-step-message-background);
        border: 1px solid var(--plan-step-message-border);
        display: flex;
        flex-direction: column;
        gap: 8px;
      }
      .step-messages-container .message .message-content-wrapper {
        padding: 8px;
      }

      .child-messages-container {
        display: flex;
        flex-direction: column;
        gap: 8px;
      }
      .child-messages-container .message {
        border: 1px solid var(--plan-step-message-border);
        display: flex;
        flex-direction: column;
        gap: 8px;
      }
      .child-messages-container .message .message-content-wrapper {
        padding: 8px;
      }

      .progress-bar-container {
        width: 100%;
        height: 5px;
        background-color: var(--progress-bar-background);

        overflow: hidden;
        margin-top: 0;
        margin-bottom: 0;
        border-top-left-radius: 5px;
        border-top-right-radius: 5px;
      }

      .progress-bar-fill {
        height: 100%;
        background-color: var(--progress-bar-fill);
        width: 0%;
        transition: width 0.3s ease-in-out;
      }

      .progress-bar-container.failed .progress-bar-fill {
        background-color: #f44336;
      }
      .progress-bar-container.completed .progress-bar-fill {
        background-color: #4caf50;
      }
      .progress-bar-container.busy .progress-bar-fill {
        background-color: #ffeb3b;
      }
    </style>
  </head>
  <body ondragover="allowDrop(event)" ondrop="dropHandler(event)">
    <main>
      <div class="prompts-section" style="display: none">
        <!-- Hiding old header section -->
        <div class="prompts-header" onclick="toggleSystemPromptsList()">
          <span>System Prompt Library</span>
          <span id="system-prompts-toggle-icon">▼</span>
        </div>
        <ul
          id="system-prompts-list"
          class="prompts-list"
          style="display: none"
        ></ul>
      </div>

      <div class="prompts-section" style="display: none">
        <!-- Hiding old header section -->
        <div class="prompts-header" onclick="toggleUserPromptsList()">
          <span>User Prompt Library</span>
          <span id="user-prompts-toggle-icon">▼</span>
        </div>
        <ul
          id="user-prompts-list"
          class="prompts-list"
          style="display: none"
        ></ul>
      </div>

      <div id="enabled-tools-container"></div>
      <div id="tool-popup" class="tool-popup">
        <ul id="tool-popup-list" class="tool-list"></ul>
      </div>

      <div id="selected-provider-container"></div>
      <div id="provider-popup" class="provider-popup">
        <div class="provider-popup-header">
          <span>Providers</span>
          <div>
            <button style="display: none" onclick="handleAddProviderButton()">
              Add
            </button>
            <!-- Hiding header add button -->
          </div>
        </div>
        <ul id="provider-popup-list" class="provider-list"></ul>

        <div id="provider-form" class="provider-form">
          <h3>Add/Edit Provider</h3>
          <label for="provider-name">Name:</label>
          <input
            type="text"
            id="provider-name"
            class="form-input"
            placeholder="Provider Name"
          />
          <div class="error-message-inline" id="provider-name-error"></div>

          <label for="provider-vendor">Vendor:</label>
          <select id="provider-vendor" class="form-input">
            <option value="">Select Vendor</option>
          </select>
          <div class="error-message-inline" id="provider-vendor-error"></div>

          <label for="provider-apiKey">API Key:</label>
          <input
            type="text"
            id="provider-apiKey"
            class="form-input"
            placeholder="API Key"
          />
          <div class="error-message-inline" id="provider-apiKey-error"></div>

          <label for="provider-baseURL">Base URL (optional):</label>
          <input
            type="text"
            id="provider-baseURL"
            class="form-input"
            placeholder="Base URL (for custom servers)"
          />
          <div class="error-message-inline" id="provider-baseURL-error"></div>

          <label for="provider-model">Model:</label>
          <input
            type="text"
            id="provider-model"
            class="form-input"
            placeholder="Model Name (e.g., gpt-4, claude-v1.3)"
          />
          <div class="error-message-inline" id="provider-model-error"></div>

          <label for="provider-maxTokens">Max Tokens (optional):</label>
          <input
            type="number"
            id="provider-maxTokens"
            class="form-input"
            placeholder="Max Tokens"
          />
          <div class="error-message-inline" id="provider-maxTokens-error"></div>

          <label for="provider-temperature">Temperature (optional, 0-2):</label>
          <input
            type="number"
            id="provider-temperature"
            class="form-input"
            placeholder="Temperature (e.g., 0.7)"
            step="0.1"
            min="0"
            max="2"
          />
          <div
            class="error-message-inline"
            id="provider-temperature-error"
          ></div>

          <div class="provider-form-buttons">
            <button onclick="handleSaveProviderSettings()">Save</button>
            <button onclick="handleCancelProviderSettings()">Cancel</button>
          </div>
        </div>
      </div>

      <div id="selected-files-container"></div>
      <div class="input-area">
        <div class="input-row">
          <textarea
            id="systemPromptInput"
            rows="2"
            placeholder="Edit system prompt here..."
          ></textarea>
          <div class="prompt-buttons">
            <button onclick="toggleSystemPromptsPopup()">Load</button>
            <button onclick="addSystemPromptToLibrary()">Save</button>
          </div>
        </div>
        <div id="system-prompts-popup" class="prompt-popup">
          <ul id="system-prompts-popup-list" class="prompts-list"></ul>
        </div>

        <div class="input-row">
          <textarea
            id="userInput"
            rows="4"
            placeholder="Type your message here..."
          ></textarea>
          <div class="prompt-buttons">
            <button onclick="toggleUserPromptsPopup()">Load</button>
            <button onclick="addUserPromptToLibrary()">Save</button>
          </div>
        </div>
        <div id="user-prompts-popup" class="prompt-popup">
          <ul id="user-prompts-popup-list" class="prompts-list"></ul>
        </div>

        <div class="button-row">
          <button id="sendButton" onclick="handleSendMessage()">
            <span id="buttonText">Send</span>
            <span id="loader" class="loader" style="display: none"></span>
          </button>
          <button id="planButton" onclick="handlePlanAndExecute()">
            <span id="planButtonText">Plan & Execute</span>
            <span id="planLoader" class="loader" style="display: none"></span>
          </button>
          <button id="clearButton" onclick="clearChatHistory()">Clear</button>
          <button id="addFilesButton" onclick="addFilesDialog()">
            Add Files
          </button>
          <button id="addToolButton" onclick="toggleToolPopup()">
            Add Tool
          </button>
          <button
            id="providerSettingsButton"
            onclick="toggleProviderSettingsPopup()"
          >
            Providers
          </button>
          <div class="auto-checkbox">
            <input type="checkbox" id="autoRemoveCommentsCheckbox" />
            <label for="autoRemoveCommentsCheckbox">Auto Remove Comments</label>
          </div>
          <button id="removeCommentsButton" onclick="handleRemoveComments()">
            Remove Comments
          </button>
          <div class="auto-checkbox">
            <input type="checkbox" id="autoFormatCheckbox" />
            <label for="autoFormatCheckbox">Auto Format</label>
          </div>
          <button id="formatButton" onclick="handleFormat()">Format</button>
          <div class="auto-checkbox">
            <input type="checkbox" id="autoFixErrorsCheckbox" />
            <label for="autoFixErrorsCheckbox">Auto Fix Errors</label>
          </div>
          <button id="fixErrorsButton" onclick="handleFixErrors()">
            Fix Errors
          </button>
          <button id="commitFilesButton" onclick="handleCommitFiles()">
            Commit Files
          </button>
          <!-- New Commit Files Button -->
          <button id="testTaskButton" onclick="handleTestTask()">
            Test Task Logger
          </button>
          <!-- New Test Task Logger Button -->
          <button id="testMultiTaskButton" onclick="handleTestMultiTask()">
            Test Multi Task
          </button>
          <!-- New Test Multi Task Button -->
          <button id="testSerialTaskButton" onclick="handleTestSerialTask()">
            Test Serial Task
          </button>
          <!-- New Test Serial Task Button -->
        </div>
      </div>

      <div id="plan-container">
        <h3 id="plan-goal">AI Plan:</h3>
        <div id="plan-steps">
          <!-- Plan steps will be rendered here -->
        </div>
        <div id="plan-error"></div>
        <div id="plan-controls">
          <!-- Plan control buttons will be rendered here -->
        </div>
      </div>

      <div id="messages-container"></div>
    </main>
    <script>
      const vscode = acquireVsCodeApi();
      const tabId = "${tabId}";

      /**
       * @typedef {Object} ChatMessage
       * @property {string} id
       * @property {string} summary - A short summary for the header.
       * @property {string} [detail] - The full content of the message (optional).
       * @property {string} [sender] - Sender of the message (user, assistant, etc.)
       * @property {string} [messageType] - Type of message for styling (user, assistant, log, etc.)
       * @property {boolean} [isCollapsed] - If the message content is collapsed
       * @property {number} [stepIndex] - Optional step index if message belongs to a plan step
       * @property {string} [text] - Kept for backward compatibility, prefer 'detail'.
       */
      /** @type {ChatMessage[]} */
      let chatHistory = [];
      /** @type {string[]} */
      let openFiles = [];
      /** @type {string[]} */
      let systemPrompts = [];
      /** @type {string[]} */
      let userPrompts = [];
      /** @type {string[]} */
      let availableTools = [];
      /** @type {string[]} */
      let enabledTools = [];
      /** @type {Array<AiProviderSettings>} */
      let providerSettingsList = [];
      /** @type {AiProviderSettings | undefined} */
      let currentProviderSetting = undefined;
      /** @type {string[]} */
      let availableVendors = [];
      let systemPromptsPopupVisible = false;
      let userPromptsPopupVisible = false;
      let toolPopupVisible = false;
      let providerSettingsPopupVisible = false;
      let editingProviderName = null;
      /** @type {string} */
      let currentSystemPrompt = "";
      /** @type {string} */
      let currentUserPrompt = "";
      let providerFormChanged = false;
      /** @type {boolean} */
      let autoRemoveComments = true;
      /** @type {boolean} */
      let autoFormat = true;
      /** @type {boolean} */
      let autoFixErrors = true;

      /**
       * @typedef {Object} PlanStep
       * @property {string} description
       * @property {string} subPrompt
       * @property {boolean} [isCollapsed] - If the step content is collapsed
       */
      /**
       * @typedef {Object} AIPlan
       * @property {string} overallGoal
       * @property {PlanStep[]} steps
       */
      /**
       * @typedef {Object} PlanState
       * @property {'idle' | 'planning' | 'executing' | 'paused' | 'failed' | 'completed'} status
       * @property {number} currentStepIndex
       * @property {AIPlan | null} plan
       * @property {string | null} error
       * @property {string[]} filePaths
       * @property {AiProviderSettings | null} providerSetting
       * @property {boolean} autoRemoveComments
       * @property {boolean} autoFormat
       * @property {boolean} autoFixErrors
       * @property {boolean[]} [stepCollapsedStates] - Array to store collapse state for each step
       * @property {string} tabId - The tab ID this plan state belongs to
       */
      /** @type {PlanState} */
      let planState = {
        status: "idle",
        currentStepIndex: -1,
        plan: null,
        error: null,
        filePaths: [],
        providerSetting: null,
        autoRemoveComments: true,
        autoFormat: true,
        autoFixErrors: true,
        stepCollapsedStates: [],
        tabId: tabId,
      };

      const STORAGE_KEYS = {
        chatHistory: `chatMessages-${tabId}`,
        userInput: `userInput-${tabId}`,
        openFiles: `openFiles-${tabId}`,
        enabledTools: "enabledTools",
        currentProviderSettingName: "currentProviderSettingName",
        autoRemoveComments: `autoRemoveComments-${tabId}`,
        autoFormat: `autoFormat-${tabId}`,
        autoFixErrors: `autoFixErrors-${tabId}`,
        planState: `planState-${tabId}`,
      };

      const messagesContainer = document.getElementById("messages-container");
      const userInputEl = document.getElementById("userInput");
      const systemPromptEl = document.getElementById("systemPromptInput");
      const sendButton = document.getElementById("sendButton");
      const buttonText = document.getElementById("buttonText");
      const loader = document.getElementById("loader");
      const planButton = document.getElementById("planButton");
      const planButtonText = document.getElementById("planButtonText");
      const planLoader = document.getElementById("planLoader");
      const selectedFilesContainer = document.getElementById(
        "selected-files-container"
      );
      const enabledToolsContainer = document.getElementById(
        "enabled-tools-container"
      );
      const systemPromptsPopupEl = document.getElementById(
        "system-prompts-popup"
      );
      const userPromptsPopupEl = document.getElementById("user-prompts-popup");
      const systemPromptsPopupListEl = document.getElementById(
        "system-prompts-popup-list"
      );
      const userPromptsPopupListEl = document.getElementById(
        "user-prompts-popup-list"
      );
      const systemPromptLoadButton = document.querySelector(
        "#systemPromptInput + .prompt-buttons > button:nth-child(1)"
      );
      const userPromptLoadButton = document.querySelector(
        "#userInput + .prompt-buttons > button:nth-child(1)"
      );
      const toolPopupEl = document.getElementById("tool-popup");
      const toolPopupListEl = document.getElementById("tool-popup-list");
      const addToolButton = document.getElementById("addToolButton");
      const selectedProviderContainer = document.getElementById(
        "selected-provider-container"
      );
      const providerSettingsPopupEl = document.getElementById("provider-popup");
      const providerSettingsPopupListEl = document.getElementById(
        "provider-popup-list"
      );
      const providerSettingsButton = document.getElementById(
        "providerSettingsButton"
      );
      const providerFormEl = document.getElementById("provider-form");
      const providerNameInput = document.getElementById("provider-name");
      const providerVendorInput = document.getElementById("provider-vendor");
      const providerApiKeyInput = document.getElementById("provider-apiKey");
      const providerBaseURLInput = document.getElementById("provider-baseURL");
      const providerModelInput = document.getElementById("provider-model");
      const providerMaxTokensInput =
        document.getElementById("provider-maxTokens");
      const providerTemperatureInput = document.getElementById(
        "provider-temperature"
      );
      const providerNameError = document.getElementById("provider-name-error");
      const providerVendorError = document.getElementById(
        "provider-vendor-error"
      );
      const providerApiKeyError = document.getElementById(
        "provider-apiKey-error"
      );
      const providerModelError = document.getElementById(
        "provider-model-error"
      );
      const providerTemperatureError = document.getElementById(
        "provider-temperature-error"
      );
      const removeCommentsButton = document.getElementById(
        "removeCommentsButton"
      );
      const formatButton = document.getElementById("formatButton");
      const fixErrorsButton = document.getElementById("fixErrorsButton");
      const autoRemoveCommentsCheckbox = document.getElementById(
        "autoRemoveCommentsCheckbox"
      );
      const autoFormatCheckbox = document.getElementById("autoFormatCheckbox");
      const autoFixErrorsCheckbox = document.getElementById(
        "autoFixErrorsCheckbox"
      );
      const commitFilesButton = document.getElementById("commitFilesButton");
      const testTaskButton = document.getElementById("testTaskButton");
      const testMultiTaskButton = document.getElementById(
        "testMultiTaskButton"
      );
      const testSerialTaskButton = document.getElementById(
        "testSerialTaskButton"
      );

      const planContainer = document.getElementById("plan-container");
      const planGoalEl = document.getElementById("plan-goal");
      const planStepsEl = document.getElementById("plan-steps");
      const planErrorEl = document.getElementById("plan-error");
      const planControlsEl = document.getElementById("plan-controls");

      /**
       * @typedef {Object} AiProviderSettings
       * @property {string} name
       * @property {string} vendor
       * @property {string} apiKey
       * @property {string} [baseURL]
       * @property {string} model
       * @property {number} [max_tokens]
       * @property {number} [temperature]
       */

      /**
       * Loads state from localStorage: chat history, open files.
       * Note: Plan state, prompts, auto settings, enabled tools, current provider
       * are loaded from workspaceState/globalState via initPrompts message.
       */
      function loadState() {
        chatHistory = loadFromLocalStorage(STORAGE_KEYS.chatHistory, []);
        openFiles = loadFromLocalStorage(STORAGE_KEYS.openFiles, []);
      }

      /**
       * Helper function to load and parse JSON data from localStorage.
       * @param {string} key - localStorage key
       * @param {any} defaultValue - Default value if key not found or parsing fails.
       * @returns {any} - Parsed data or defaultValue.
       */
      function loadFromLocalStorage(key, defaultValue) {
        const data = localStorage.getItem(key);
        try {
          return data ? JSON.parse(data) : defaultValue;
        } catch (e) {
          console.error(`Error parsing localStorage key ${key}: `, e);
          return defaultValue;
        }
      }

      /**
       * Saves state to localStorage: chat history, open files.
       * Checkbox states, plan state, enabled tools, current provider are saved to workspaceState/globalState via extension messages.
       */
      function saveState() {
        saveToLocalStorage(STORAGE_KEYS.chatHistory, chatHistory);
        saveToLocalStorage(STORAGE_KEYS.openFiles, openFiles);
      }

      /**
       * Helper function to save data to localStorage as JSON.
       * @param {string} key - localStorage key
       * @param {any} data - Data to stringify and save.
       */
      function saveToLocalStorage(key, data) {
        localStorage.setItem(key, JSON.stringify(data));
      }

      /**
       * Renders the entire chat history to the DOM.
       */
      function renderChatHistory() {
        messagesContainer.innerHTML = "";
        chatHistory.forEach((msg) => {
          renderMessage({
            id: msg.id,
            type: msg.messageType,
            summary: msg.summary,
            detail: msg.detail,
            isCollapsed: msg.isCollapsed,
          });
        });
        scrollToBottom();
      }

      /**
       * Creates and appends a message element to the DOM.
       * @param {object} params - Parameters for the message.
       * @param {string} params.id - Unique ID for the message element.
       * @param {string} [params.type='log'] - Type of message for styling and badge.
       * @param {string} [params.summary] - Short summary for the message header.
       * @param {string} [params.detail] - Full detail for the collapsible content.
       * @param {number} [params.progress] - Progress value (0 to 1) for a task.
       * @param {boolean} [params.isCollapsed=false] - Initial collapsed state.
       * @param {HTMLElement} [targetContainer=messagesContainer] - The container to append the message to.
       */
      function renderMessage(
        { id, type = "log", summary, detail, progress, isCollapsed = false },
        targetContainer = messagesContainer
      ) {
        const el = document.createElement("pre");
        el.classList.add("message");
        el.classList.add(`${type}-message`);
        if (["prompt", "tool"].includes(type)) {
          el.classList.add("tool-message");
        }
        if (id) el.id = `message-${id}`;

        if (progress !== undefined) {
          const progressBarContainer = document.createElement("div");
          progressBarContainer.classList.add("progress-bar-container");
          const progressBarFill = document.createElement("div");
          progressBarFill.classList.add("progress-bar-fill");
          const width = Math.max(0, Math.min(1, progress)) * 100;
          progressBarFill.style.width = `${width}%`;
          if (progress < 0) {
            progressBarContainer.classList.add("failed");
          } else if (progress === 1) {
            progressBarContainer.classList.add("completed");
          } else if (progress > 0 && progress < 1) {
            progressBarContainer.classList.add("busy");
          }
          progressBarContainer.appendChild(progressBarFill);
          el.appendChild(progressBarContainer);
        }

        const messageContentWrapper = document.createElement("div");
        messageContentWrapper.classList.add("message-content-wrapper");

        const headerDiv = document.createElement("div");
        headerDiv.classList.add("message-header");

        const previewSpan = document.createElement("span");
        previewSpan.classList.add("message-preview");
        previewSpan.textContent = summary !== undefined ? summary : "";
        headerDiv.appendChild(previewSpan);

        const badge = document.createElement("span");
        badge.classList.add("message-type-badge");
        badge.textContent = type;
        headerDiv.appendChild(badge);

        const cancelButton = document.createElement("button");
        cancelButton.classList.add("cancel-button");
        cancelButton.textContent = "✕";
        cancelButton.title = "Cancel Task";
        cancelButton.style.display = "none";
        cancelButton.onclick = (event) => {
          event.stopPropagation();
          handleCancelTask(id);
        };
        headerDiv.appendChild(cancelButton);

        const collapseButton = document.createElement("button");
        collapseButton.classList.add("collapse-button");
        collapseButton.textContent = isCollapsed ? "▼" : "▲";
        headerDiv.appendChild(collapseButton);

        messageContentWrapper.appendChild(headerDiv);

        const contentDiv = document.createElement("div");
        contentDiv.classList.add("collapsible-content");
        contentDiv.classList.toggle("collapsed", isCollapsed);

        const messageBodyContentDiv = document.createElement("div");
        messageBodyContentDiv.classList.add("message-body-content");

        const messageDetailTextDiv = document.createElement("div");
        messageDetailTextDiv.classList.add("message-detail-text");
        messageDetailTextDiv.textContent = detail || "";
        messageBodyContentDiv.appendChild(messageDetailTextDiv);

        const childMessagesContainer = document.createElement("div");
        childMessagesContainer.classList.add("child-messages-container");
        childMessagesContainer.style.display = isCollapsed ? "none" : "";
        messageBodyContentDiv.appendChild(childMessagesContainer);

        contentDiv.appendChild(messageBodyContentDiv);
        messageContentWrapper.appendChild(contentDiv);

        el.appendChild(messageContentWrapper);

        updateMessageCollapsibility(el);
        updateCancelButtonVisibility(el, type, progress);

        targetContainer.appendChild(el);
      }

      /**
       * Updates an existing message element in the DOM.
       * @param {string} id - ID of the message element to update.
       * @param {object} params - Parameters for the update.
       * @param {string} [params.type] - New type of message.
       * @param {string} [params.summary] - New summary.
       * @param {string} [params.detail] - New detail.
       * @param {number} [params.progress] - New progress value.
       * @param {HTMLElement} [container=messagesContainer] - The container where the message is rendered.
       */
      function updateMessageElement(
        id,
        { type, summary, detail, progress },
        container = messagesContainer
      ) {
        const el = container.querySelector(`#message-${id}`);
        if (!el) return;

        const contentDiv = el.querySelector(".collapsible-content");
        const previewSpan = el.querySelector(".message-preview");
        const badge = el.querySelector(".message-type-badge");
        const messageDetailTextDiv = el.querySelector(".message-detail-text");
        let progressBarContainer = el.querySelector(".progress-bar-container");
        let progressBarFill = el.querySelector(".progress-bar-fill");
        const childMessagesContainer = el.querySelector(
          ".child-messages-container"
        );
        const currentType = el.classList.contains("user-message")
          ? "user"
          : el.classList.contains("assistant-message")
          ? "assistant"
          : el.classList.contains("system-message")
          ? "system"
          : el.classList.contains("prompt-message")
          ? "prompt"
          : el.classList.contains("tool-message")
          ? "tool"
          : el.classList.contains("log-message")
          ? "log"
          : el.classList.contains("error-message")
          ? "error"
          : el.classList.contains("warning-message")
          ? "warning"
          : el.classList.contains("info-message")
          ? "info"
          : el.classList.contains("loading-message")
          ? "loading"
          : "log";

        if (summary !== undefined && previewSpan) {
          previewSpan.textContent = summary;
        }

        if (detail !== undefined && messageDetailTextDiv) {
          messageDetailTextDiv.textContent = detail;
          updateMessageCollapsibility(el);
        }
        if (type !== undefined && badge) {
          badge.textContent = type;
          el.classList.remove(
            "user-message",
            "assistant-message",
            "system-message",
            "prompt-message",
            "tool-message",
            "log-message",
            "error-message",
            "warning-message",
            "info-message",
            "loading-message"
          );
          el.classList.add(`${type}-message`);
          if (["prompt", "tool"].includes(type)) {
            el.classList.add("tool-message");
          }
        }

        if (progress !== undefined) {
          if (!progressBarContainer) {
            progressBarContainer = document.createElement("div");
            progressBarContainer.classList.add("progress-bar-container");
            progressBarFill = document.createElement("div");
            progressBarFill.classList.add("progress-bar-fill");
            progressBarContainer.appendChild(progressBarFill);
            const messageContentWrapper = el.querySelector(
              ".message-content-wrapper"
            );
            if (messageContentWrapper) {
              messageContentWrapper.before(progressBarContainer);
            } else {
              el.prepend(progressBarContainer);
            }
          } else {
            progressBarContainer.style.display = "";
          }

          const width = Math.max(0, Math.min(1, progress)) * 100;
          progressBarFill.style.width = `${width}%`;

          progressBarContainer.classList.remove("failed", "completed", "busy");
          if (progress < 0) {
            progressBarContainer.classList.add("failed");
          } else if (progress === 1) {
            progressBarContainer.classList.add("completed");
          } else if (progress > 0 && progress < 1) {
            progressBarContainer.classList.add("busy");
          }
        } else if (progressBarContainer) {
          progressBarContainer.style.display = "none";
        }

        updateCancelButtonVisibility(el, type || currentType, progress);
      }

      /**
       * Updates the collapsibility state of a message element based on its content.
       * Hides/shows the collapse button and sets the non-collapsible class on the header.
       * @param {HTMLElement} messageEl - The message element (<pre>) to update.
       */
      function updateMessageCollapsibility(messageEl) {
        if (!messageEl) return;

        const headerDiv = messageEl.querySelector(".message-header");
        const contentDiv = messageEl.querySelector(".collapsible-content");
        const collapseButton = messageEl.querySelector(".collapse-button");
        const detailTextDiv = messageEl.querySelector(".message-detail-text");
        const childMessagesContainer = messageEl.querySelector(
          ".child-messages-container"
        );

        const hasDetailText =
          detailTextDiv && detailTextDiv.textContent.trim() !== "";
        const hasChildMessages =
          childMessagesContainer && childMessagesContainer.children.length > 0;
        const isCollapsible = hasDetailText || hasChildMessages;

        if (isCollapsible) {
          headerDiv.classList.remove("non-collapsible");
          if (collapseButton) collapseButton.style.display = "";
        } else {
          headerDiv.classList.add("non-collapsible");
          if (collapseButton) collapseButton.style.display = "none";
          if (contentDiv) contentDiv.classList.add("collapsed");
          if (childMessagesContainer)
            childMessagesContainer.style.display = "none";
        }
      }

      /**
       * Updates the visibility of the cancel button based on message type and progress.
       * @param {HTMLElement} messageEl - The message element (<pre>) to update.
       * @param {string} type - The message type. // Keep type parameter for context, but don't use it for visibility check
       * @param {number} [progress] - The progress value.
       */
      function updateCancelButtonVisibility(messageEl, type, progress) {
        if (!messageEl) return;
        const cancelButton = messageEl.querySelector(".cancel-button");
        if (cancelButton) {
          const isBusy =
            progress !== undefined && progress >= 0 && progress < 1;
          cancelButton.style.display = isBusy ? "" : "none";
        }
      }

      /**
       * Updates an existing chat message in the chatHistory array.
       * This is primarily for main chat messages that need persistence.
       * @param {string} id - ID of the message to update.
       * @param {string} [newDetail] - New message detail text (optional).
       * @param {string} [newSummary] - New message summary (optional).
       * @param {string} newSender - New sender.
       * @param {string} [newMessageType] - New message type (optional).
       */
      function updateMainChatMessageHistory(
        id,
        newDetail,
        newSummary,
        newSender,
        newMessageType
      ) {
        const msg = chatHistory.find((m) => m.id === id);
        if (msg) {
          msg.detail = newDetail;
          if (newDetail !== undefined) {
            msg.detail = newDetail;
          }
          if (newSummary !== undefined) {
            msg.summary = newSummary;
          }
          msg.sender = newSender;
          if (newMessageType !== undefined) {
            msg.messageType = newMessageType;
          }
          saveState();
        }
      }

      /**
       * Toggles the collapsed state of a message and updates the DOM.
       * @param {string} messageId - ID of the message to toggle.
       * @param {HTMLElement} [container=messagesContainer] - The container where the message is rendered.
       */
      function toggleMessageCollapse(messageId, container = messagesContainer) {
        const el = container.querySelector(`#message-${messageId}`);
        if (!el) return;

        const contentDiv = el.querySelector(".collapsible-content");
        const collapseButton = el.querySelector(".collapse-button");
        const progressBarContainer = el.querySelector(
          ".progress-bar-container"
        );
        const childMessagesContainer = el.querySelector(
          ".child-messages-container"
        );
        const headerDiv = el.querySelector(".message-header");

        if (headerDiv.classList.contains("non-collapsible")) {
          return;
        }

        if (contentDiv && collapseButton) {
          const isCollapsed = contentDiv.classList.toggle("collapsed");
          collapseButton.textContent = isCollapsed ? "▼" : "▲";

          if (progressBarContainer) {
            const isCompletedOrFailed =
              progressBarContainer.classList.contains("completed") ||
              progressBarContainer.classList.contains("failed");
            progressBarContainer.style.display =
              isCollapsed && !isCompletedOrFailed ? "none" : "";
          }

          if (childMessagesContainer) {
            childMessagesContainer.style.display = isCollapsed ? "none" : "";
          }

          if (container === messagesContainer) {
            const msg = chatHistory.find((m) => m.id === messageId);
            if (msg) {
              msg.isCollapsed = isCollapsed;
              saveState();
            }
          }
        }
      }

      /**
       * Clears chat history from memory and localStorage, then re-renders.
       */
      function clearChatHistory() {
        chatHistory = [];
        localStorage.removeItem(STORAGE_KEYS.chatHistory);
        messagesContainer.innerHTML = "";
      }

      /**
       * Scrolls the messages container to the bottom.
       */
      function scrollToBottom() {
        messagesContainer.scrollTop = messagesContainer.scrollHeight;
        planContainer.scrollTop = planContainer.scrollHeight;
      }

      /**
       * Debounces a function call.
       * @param {Function} func - Function to debounce.
       * @param {number} delay - Delay in milliseconds.
       * @returns {Function} - Debounced function.
       */
      function debounce(func, delay) {
        let timeout;
        return (...args) => {
          clearTimeout(timeout);
          timeout = setTimeout(() => func(...args), delay);
        };
      }

      const updateSystemPrompt = debounce((value) => {
        vscode.postMessage({ command: "setSystemPrompt", systemPrompt: value });
      }, 3000);

      const updateUserPrompt = debounce((value) => {
        localStorage.setItem(STORAGE_KEYS.userInput, value);
        vscode.postMessage({ command: "setUserPrompt", userPrompt: value });
      }, 3000);

      const updateProviderSettingDebounced = debounce(() => {
        if (providerFormChanged) {
          handleSaveProviderSettings();
          providerFormChanged = false;
        }
      }, 500);

      /**
       * Resets the send button state to enable and hide loader.
       */
      function resetSendButton() {
        sendButton.disabled = false;
        loader.style.display = "none";
        buttonText.textContent = "Send";
      }

      /**
       * Resets the plan button state to enable and hide loader.
       */
      function resetPlanButton() {
        planButton.disabled = false;
        planLoader.style.display = "none";
        planButtonText.textContent = "Plan & Execute";
      }

      /**
       * Renders the selected files in the UI.
       */
      function renderSelectedFiles() {
        selectedFilesContainer.innerHTML = "";
        openFiles.forEach((filePath) => {
          const fileButton = document.createElement("div");
          fileButton.classList.add("file-button");
          fileButton.textContent = filePath;

          const removeButton = document.createElement("button");
          removeButton.classList.add("remove-file-button");
          removeButton.textContent = "✕";
          removeButton.onclick = () => removeFile(filePath);

          fileButton.appendChild(removeButton);
          selectedFilesContainer.appendChild(fileButton);
        });
      }

      /**
       * Renders the enabled tools in the UI.
       */
      function renderEnabledTools() {
        enabledToolsContainer.innerHTML = "";
        enabledTools.forEach((toolName) => {
          const toolButton = document.createElement("div");
          toolButton.classList.add("tool-button");
          toolButton.textContent = toolName;

          const removeButton = document.createElement("button");
          removeButton.classList.add("remove-tool-button");
          removeButton.textContent = "✕";
          removeButton.onclick = () => disableTool(toolName);

          toolButton.appendChild(removeButton);
          enabledToolsContainer.appendChild(toolButton);
        });
      }

      /**
       * Renders the selected provider in the UI.
       */
      function renderSelectedProvider() {
        selectedProviderContainer.innerHTML = "";
        if (currentProviderSetting) {
          const providerButton = document.createElement("div");
          providerButton.classList.add("provider-button");
          providerButton.textContent = currentProviderSetting.name;

          selectedProviderContainer.appendChild(providerButton);
        }
      }

      /**
       * Removes a file from the open files list and updates UI and extension.
       * @param {string} filePath - Path of the file to remove.
       */
      function removeFile(filePath) {
        openFiles = openFiles.filter((file) => file !== filePath);
        saveState();
        renderSelectedFiles();

        vscode.postMessage({ command: "removeFile", filePath: filePath });
      }

      /**
       * Adds files to the open files list, updates UI and extension.
       * Prevents duplicate file paths.
       * @param {string[]} files - Array of file paths to add.
       */
      function addFiles(files) {
        const newFiles = files.filter(
          (filePath) => !openFiles.includes(filePath)
        );
        if (newFiles.length > 0) {
          openFiles.push(...newFiles);
          saveState();
          renderSelectedFiles();

          vscode.postMessage({ command: "addFiles", filePaths: newFiles });
        }
      }

      /**
       * Opens the file dialog to add files.
       */
      function addFilesDialog() {
        vscode.postMessage({ command: "requestAddFiles" });
      }

      /**
       * Allows drag over event for drag and drop file functionality.
       * @param {DragEvent} event
       */
      function allowDrop(event) {
        event.preventDefault();
      }

      /**
       * Handles the drop event for drag and drop file functionality.
       * @param {DragEvent} event
       */
      async function dropHandler(event) {
        event.preventDefault();
        let filePaths = [];
        if (event.dataTransfer.items) {
          const items = Array.from(event.dataTransfer.items);
          filePaths = await Promise.all(
            items.map((item) => {
              if (item.kind === "file") {
                const file = item.getAsFile();
                return file ? file.path : null;
              }
              return null;
            })
          ).then((paths) => paths.filter((path) => path !== null));
        } else {
          filePaths = Array.from(event.dataTransfer.files).map(
            (file) => file.path
          );
        }

        if (filePaths.length > 0) {
          vscode.postMessage({
            command: "addFilesFromDialog",
            filePaths: filePaths,
          });
        }
      }

      /**
       * Handles sending a message to the extension.
       */
      function handleSendMessage() {
        if (sendButton.disabled) return;
        const user = userInputEl.value.trim();
        const system = systemPromptEl.value.trim();
        if (!user) {
          alert("Please enter a message before sending.");
          return;
        }
        if (!currentProviderSetting) {
          alert("Please select an AI Provider in 'Providers' popup.");
          return;
        }

        sendButton.disabled = true;
        loader.style.display = "inline-block";
        buttonText.textContent = "";

        const autoRemoveComments = autoRemoveCommentsCheckbox.checked;
        const autoFormat = autoFormatCheckbox.checked;
        const autoFixErrors = autoFixErrorsCheckbox.checked;

        const messageId = Date.now().toString();

        vscode.postMessage({
          command: "sendMessage",
          user: user,
          system: system,
          fileNames: openFiles,
          toolNames: enabledTools,
          providerSetting: currentProviderSetting,
          messageId,
          autoRemoveComments: autoRemoveComments,
          autoFormat: autoFormat,
          autoFixErrors: autoFixErrors,
        });
      }

      /**
       * Handles initiating the plan and execute mode.
       */
      function handlePlanAndExecute() {
        if (planButton.disabled) return;
        const user = userInputEl.value.trim();
        const system = systemPromptEl.value.trim();
        if (!user) {
          alert("Please enter a user prompt describing the task for the plan.");
          return;
        }
        if (!currentProviderSetting) {
          alert(
            "Please select an AI Provider in 'Providers' popup before planning."
          );
          return;
        }

        planButton.disabled = true;
        planLoader.style.display = "inline-block";
        planButtonText.textContent = "";

        const autoRemoveComments = autoRemoveCommentsCheckbox.checked;
        const autoFormat = autoFormatCheckbox.checked;
        const autoFixErrors = autoFixErrorsCheckbox.checked;

        planStepsEl.innerHTML = "";
        planGoalEl.textContent = "AI Plan:";
        planErrorEl.style.display = "none";
        planControlsEl.innerHTML = "";
        planContainer.style.display = "block";

        vscode.postMessage({
          command: "planAndExecute",
          user: user,
          system: system,
          fileNames: openFiles,
          providerSetting: currentProviderSetting,
          autoRemoveComments: autoRemoveComments,
          autoFormat: autoFormat,
          autoFixErrors: autoFixErrors,
        });
      }

      /**
       * Handles pausing the plan execution.
       */
      function handlePausePlan() {
        vscode.postMessage({ command: "pausePlan" });
      }

      /**
       * Handles resuming the plan execution.
       */
      function handleResumePlan() {
        vscode.postMessage({ command: "resumePlan" });
      }

      /**
       * Handles stopping the plan execution.
       */
      function handleStopPlan() {
        vscode.postMessage({ command: "stopPlan" });
      }

      /**
       * Handles cancelling a specific task.
       * @param {string} taskId - The ID of the task to cancel.
       */
      function handleCancelTask(taskId) {
        vscode.postMessage({ command: "cancelTask", id: taskId });
      }

      /**
       * Handles removing comments from selected files.
       */
      function handleRemoveComments() {
        if (openFiles.length === 0) {
          alert("Please add files first.");
          return;
        }
        vscode.postMessage({
          command: "removeCommentsInFiles",
          filePaths: openFiles,
        });
      }

      /**
       * Handles formatting selected files.
       */
      function handleFormat() {
        if (openFiles.length === 0) {
          alert("Please add files first.");
          return;
        }
        vscode.postMessage({
          command: "formatFilesInFiles",
          filePaths: openFiles,
        });
      }

      /**
       * Handles fixing errors in selected files.
       */
      function handleFixErrors() {
        if (openFiles.length === 0) {
          alert("Please add files first.");
          return;
        }
        if (!currentProviderSetting) {
          alert("Please select an AI Provider in 'Providers' popup.");
          return;
        }
        vscode.postMessage({
          command: "checkErrorsInFiles",
          filePaths: openFiles,
          providerSetting: currentProviderSetting,
        });
      }

      /**
       * Handles committing selected files.
       */
      function handleCommitFiles() {
        if (openFiles.length === 0) {
          alert("No files selected to commit.");
          return;
        }
        vscode.postMessage({ command: "commitFiles", fileNames: openFiles });
      }

      /**
       * Handles triggering the test task logger simulation.
       */
      function handleTestTask() {
        vscode.postMessage({ command: "runTestTask" });
      }

      /**
       * Handles triggering the test multi-task logger simulation.
       */
      function handleTestMultiTask() {
        vscode.postMessage({ command: "runTestMultiTask" });
      }

      /**
       * Handles triggering the test serial-task logger simulation.
       */
      function handleTestSerialTask() {
        vscode.postMessage({ command: "runTestSerialTask" });
      }

      /**
       * Displays a temporary loading message in the chat.
       * @param {string} messageId - ID to assign to the loading message.
       * @param {number} [stepIndex] - Optional step index if message belongs to a plan step.
       */
      function showLoadingMessage(messageId, stepIndex = undefined) {
        const container =
          stepIndex != undefined
            ? document.querySelector(
                `#plan-step-${stepIndex} .step-messages-container`
              )
            : messagesContainer;

        if (!container) return;

        const existingLoadingMsg = container.querySelector(
          `#message-${messageId}`
        );
        if (!existingLoadingMsg) {
          renderMessage(
            {
              id: messageId,
              type: "loading",
              summary: "Loading response...",
              detail: "Loading response...",
              progress: 0,
              isCollapsed: false,
            },
            container
          );
        }
      }

      function renderSystemPromptsList() {
        systemPromptsPopupListEl.innerHTML = "";
        systemPrompts.forEach((prompt) => {
          const listItem = document.createElement("li");
          listItem.classList.add("prompt-item");

          const textSpan = document.createElement("span");
          textSpan.classList.add("prompt-text");
          textSpan.textContent = prompt;
          listItem.onclick = () => insertSystemPrompt(prompt);

          const deleteButton = document.createElement("button");
          deleteButton.classList.add("prompt-delete-button");
          deleteButton.textContent = "✕";
          deleteButton.onclick = (event) => {
            event.stopPropagation();
            deleteSystemPrompt(prompt);
          };

          listItem.appendChild(textSpan);
          listItem.appendChild(deleteButton);
          systemPromptsPopupListEl.appendChild(listItem);
        });
      }

      function renderUserPromptsList() {
        userPromptsPopupListEl.innerHTML = "";
        userPrompts.forEach((prompt) => {
          const listItem = document.createElement("li");
          listItem.classList.add("prompt-item");

          const textSpan = document.createElement("span");
          textSpan.classList.add("prompt-text");
          textSpan.textContent = prompt;
          listItem.onclick = () => insertUserPrompt(prompt);

          const deleteButton = document.createElement("button");
          deleteButton.classList.add("prompt-delete-button");
          deleteButton.textContent = "✕";
          deleteButton.onclick = (event) => {
            event.stopPropagation();
            deleteUserPrompt(prompt);
          };

          listItem.appendChild(textSpan);
          listItem.appendChild(deleteButton);
          userPromptsPopupListEl.appendChild(listItem);
        });
      }

      function renderToolPopupList() {
        toolPopupListEl.innerHTML = "";
        availableTools.forEach((toolName) => {
          if (!enabledTools.includes(toolName)) {
            const listItem = document.createElement("li");
            listItem.classList.add("tool-item");
            listItem.textContent = toolName;
            listItem.onclick = () => enableTool(toolName);
            toolPopupListEl.appendChild(listItem);
          }
        });
      }

      function renderProviderSettingsPopupList() {
        providerSettingsPopupListEl.innerHTML = "";
        providerSettingsList.forEach((providerSetting) => {
          const listItem = document.createElement("li");
          listItem.classList.add("provider-item");

          const textSpan = document.createElement("span");
          textSpan.classList.add("prompt-text");
          textSpan.textContent = providerSetting.name;
          listItem.onclick = () => selectProviderSetting(providerSetting.name);

          const editButton = document.createElement("button");
          editButton.classList.add("select-provider-button");
          editButton.textContent = "✏️";
          editButton.title = "Edit";
          editButton.onclick = (event) => {
            event.stopPropagation();
            loadProviderSettingToForm(providerSetting);
          };

          const duplicateButton = document.createElement("button");
          duplicateButton.classList.add("duplicate-provider-button");
          duplicateButton.textContent = "📄";
          duplicateButton.title = "Duplicate";
          duplicateButton.onclick = (event) => {
            event.stopPropagation();
            handleDuplicateProviderSetting(providerSetting.name);
          };

          const deleteButton = document.createElement("button");
          deleteButton.classList.add("prompt-delete-button");
          deleteButton.textContent = "🗑️";
          deleteButton.title = "Delete";
          deleteButton.onclick = (event) => {
            event.stopPropagation();
            deleteProviderSetting(providerSetting.name);
          };

          listItem.appendChild(textSpan);
          listItem.appendChild(duplicateButton);
          listItem.appendChild(editButton);
          listItem.appendChild(deleteButton);
          providerSettingsPopupListEl.appendChild(listItem);
        });
      }

      function renderVendorDropdown() {
        providerVendorInput.innerHTML =
          '<option value="">Select Vendor</option>';
        availableVendors.forEach((vendor) => {
          const option = document.createElement("option");
          option.value = vendor;
          option.textContent = vendor;
          providerVendorInput.appendChild(option);
        });
      }

      function toggleSystemPromptsPopup() {
        systemPromptsPopupVisible = !systemPromptsPopupVisible;
        systemPromptsPopupEl.style.display = systemPromptsPopupVisible
          ? "block"
          : "none";
        if (systemPromptsPopupVisible) {
          renderSystemPromptsList();
          positionSystemPromptsPopup();
        }
      }

      function toggleUserPromptsPopup() {
        userPromptsPopupVisible = !userPromptsPopupVisible;
        userPromptsPopupEl.style.display = userPromptsPopupVisible
          ? "block"
          : "none";
        if (userPromptsPopupVisible) {
          renderUserPromptsList();
          positionUserPromptsPopup();
        }
      }

      function toggleToolPopup() {
        toolPopupVisible = !toolPopupVisible;
        toolPopupEl.style.display = toolPopupVisible ? "block" : "none";
        if (toolPopupVisible) {
          renderToolPopupList();
          positionToolPopup();
        }
      }

      function toggleProviderSettingsPopup() {
        providerSettingsPopupVisible = !providerSettingsPopupVisible;
        providerSettingsPopupEl.style.display = providerSettingsPopupVisible
          ? "block"
          : "none";
        if (providerSettingsPopupVisible) {
          renderProviderSettingsPopupList();
          positionProviderSettingsPopup();
          renderVendorDropdown();
        }
      }

      function positionSystemPromptsPopup() {
        const buttonRect = systemPromptLoadButton.getBoundingClientRect();
        systemPromptsPopupEl.style.top = `${
          buttonRect.bottom + window.scrollY
        }px`;
        systemPromptsPopupEl.style.right = `${
          window.innerWidth - buttonRect.right
        }px`;
      }

      function positionUserPromptsPopup() {
        const buttonRect = userPromptLoadButton.getBoundingClientRect();
        userPromptsPopupEl.style.top = `${
          buttonRect.bottom + window.scrollY
        }px`;
        userPromptsPopupEl.style.right = `${
          window.innerWidth - buttonRect.right
        }px`;
      }

      function positionToolPopup() {
        const buttonRect = addToolButton.getBoundingClientRect();
        toolPopupEl.style.top = `${buttonRect.bottom + window.scrollY}px`;
        toolPopupEl.style.right = `${window.innerWidth - buttonRect.right}px`;
      }

      function positionProviderSettingsPopup() {
        const buttonRect = providerSettingsButton.getBoundingClientRect();
        providerSettingsPopupEl.style.top = `${
          buttonRect.bottom + window.scrollY
        }px`;
        providerSettingsPopupEl.style.right = `${
          window.innerWidth - buttonRect.right
        }px`;
      }

      function addSystemPromptToLibrary() {
        const prompt = systemPromptEl.value.trim();
        if (prompt) {
          vscode.postMessage({
            command: "saveSystemPromptToLibrary",
            prompt: prompt,
          });
        }
      }

      function addUserPromptToLibrary() {
        const prompt = userInputEl.value.trim();
        if (prompt) {
          vscode.postMessage({
            command: "saveUserPromptToLibrary",
            prompt: prompt,
          });
        }
      }

      function deleteSystemPrompt(prompt) {
        vscode.postMessage({
          command: "deleteSystemPromptFromLibrary",
          prompt: prompt,
        });
      }

      function deleteUserPrompt(prompt) {
        vscode.postMessage({
          command: "deleteUserPromptFromLibrary",
          prompt: prompt,
        });
      }

      function deleteProviderSetting(providerSettingName) {
        vscode.postMessage({
          command: "deleteProviderSettingFromLibrary",
          providerSettingName: providerSettingName,
        });
      }

      function insertSystemPrompt(prompt) {
        systemPromptEl.value = prompt;
        vscode.postMessage({
          command: "useSystemPromptFromLibrary",
          prompt: prompt,
        });
        toggleSystemPromptsPopup();
      }

      function insertUserPrompt(prompt) {
        userInputEl.value = prompt;
        vscode.postMessage({
          command: "useUserPromptFromLibrary",
          prompt: prompt,
        });
        toggleUserPromptsPopup();
      }

      function enableTool(toolName) {
        if (!enabledTools.includes(toolName)) {
          enabledTools = [...enabledTools, toolName];
          saveState();
          renderEnabledTools();
          vscode.postMessage({ command: "enableTool", toolName: toolName });
        }
        toggleToolPopup();
      }

      function disableTool(toolName) {
        enabledTools = enabledTools.filter((tool) => tool !== toolName);
        saveState();
        renderEnabledTools();
        vscode.postMessage({ command: "disableTool", toolName: toolName });
      }

      function selectProviderSetting(providerSettingName) {
        const providerSetting = providerSettingsList.find(
          (p) => p.name === providerSettingName
        );
        if (providerSetting) {
          currentProviderSetting = providerSetting;
          saveState();
          renderSelectedProvider();
          vscode.postMessage({
            command: "useProviderSettingFromLibrary",
            providerSettingName: providerSettingName,
          });
        }
        toggleProviderSettingsPopup();
      }

      function loadProviderSettingToForm(providerSetting) {
        if (providerSetting) {
          editingProviderName = providerSetting.name;
          providerNameInput.value = providerSetting.name;
          providerVendorInput.value = providerSetting.vendor;
          providerApiKeyInput.value = providerSetting.apiKey;
          providerBaseURLInput.value = providerSetting.baseURL || "";
          providerModelInput.value = providerSetting.model;
          providerMaxTokensInput.value =
            providerSetting.max_tokens !== undefined
              ? String(providerSetting.max_tokens)
              : "";
          providerTemperatureInput.value =
            providerSetting.temperature !== undefined
              ? String(providerSetting.temperature)
              : "";
          clearProviderFormErrors();
        }
        providerFormChanged = false;
      }

      function handleDuplicateProviderSetting(providerSettingName) {
        const originalProviderSetting = providerSettingsList.find(
          (p) => p.name === providerSettingName
        );
        if (originalProviderSetting) {
          const newProviderSetting = { ...originalProviderSetting };
          newProviderSetting.name = `${originalProviderSetting.name} Copy`;
          vscode.postMessage({
            command: "saveProviderSetting",
            providerSetting: newProviderSetting,
          });
          loadProviderSettingToForm(newProviderSetting);
        }
      }

      function handleAddProviderButton() {
        editingProviderName = null;
        providerNameInput.value = "";
        providerVendorInput.value = "";
        providerApiKeyInput.value = "";
        providerBaseURLInput.value = "";
        providerModelInput.value = "";
        providerVendorInput.value = "";
        providerMaxTokensInput.value = "";
        providerTemperatureInput.value = "";
        clearProviderFormErrors();
        providerFormChanged = false;
      }

      function clearProviderFormErrors() {
        providerNameError.style.display = "none";
        providerVendorError.style.display = "none";
        providerApiKeyError.style.display = "none";
        providerModelError.style.display = "none";
        providerTemperatureError.style.display = "none";
      }

      function handleSaveProviderSettings() {
        const providerSetting = {
          name: providerNameInput.value.trim(),
          vendor: providerVendorInput.value,
          apiKey: providerApiKeyInput.value.trim(),
          baseURL: providerBaseURLInput.value.trim() || undefined,
          model: providerModelInput.value.trim(),
          max_tokens: providerMaxTokensInput.value.trim()
            ? parseInt(providerMaxTokensInput.value.trim(), 10)
            : undefined,
          temperature: providerTemperatureInput.value.trim()
            ? parseFloat(providerTemperatureInput.value.trim())
            : undefined,
        };

        clearProviderFormErrors();

        let isValid = true;
        if (!providerSetting.name) {
          providerNameError.textContent = "Name is required";
          providerNameError.style.display = "block";
          isValid = false;
        } else {
          if (editingProviderName === null) {
            const existingProvider = providerSettingsList.find(
              (p) => p.name === providerSetting.name
            );
            if (existingProvider) {
              providerNameError.textContent = `Provider "${providerSetting.name}" already exists.`;
              providerNameError.style.display = "block";
              isValid = false;
            }
          }
        }
        if (!providerSetting.vendor) {
          providerVendorError.textContent = "Vendor is required";
          providerVendorError.style.display = "block";
          isValid = false;
        }
        if (!providerSetting.apiKey) {
          providerApiKeyError.textContent = "API Key is required";
          providerApiKeyError.style.display = "block";
          isValid = false;
        }
        if (!providerSetting.model) {
          providerModelError.textContent = "Model is required";
          providerModelError.style.display = "block";
          isValid = false;
        }
        if (
          providerSetting.temperature !== undefined &&
          (isNaN(providerSetting.temperature) ||
            providerSetting.temperature < 0 ||
            providerSetting.temperature > 2)
        ) {
          providerTemperatureError.textContent =
            "Temperature must be a number between 0 and 2";
          providerTemperatureError.style.display = "block";
          isValid = false;
        }

        if (!isValid) {
          return;
        }

        if (editingProviderName) {
          vscode.postMessage({
            command: "updateProviderSetting",
            oldProviderSettingName: editingProviderName,
            providerSetting: providerSetting,
          });
        } else {
          vscode.postMessage({
            command: "saveProviderSetting",
            providerSetting: providerSetting,
          });
        }

        editingProviderName = null;
        handleAddProviderButton();
      }

      function handleCancelProviderSettings() {
        editingProviderName = null;
        handleAddProviderButton();
      }

      /**
       * Renders the plan steps in the UI.
       * @param {AIPlan} plan - The plan object.
       */
      function renderPlan(plan) {
        planContainer.style.display = "block";
        planGoalEl.textContent = `AI Plan: ${plan.overallGoal}`;
        planStepsEl.innerHTML = "";

        if (
          !planState.stepCollapsedStates ||
          planState.stepCollapsedStates.length !== plan.steps.length
        ) {
          planState.stepCollapsedStates = Array(plan.steps.length).fill(true);
        }

        plan.steps.forEach((step, index) => {
          const stepDiv = document.createElement("div");
          stepDiv.classList.add("plan-step");
          stepDiv.id = `plan-step-${index}`;

          const isCollapsed = planState.stepCollapsedStates[index] ?? true;

          const headerDiv = document.createElement("div");
          headerDiv.classList.add("plan-step-header");
          headerDiv.onclick = () => togglePlanStepCollapse(index);

          const statusSpan = document.createElement("span");
          statusSpan.classList.add("plan-step-status");
          statusSpan.textContent = "☐";
          headerDiv.appendChild(statusSpan);

          const previewSpan = document.createElement("span");
          previewSpan.classList.add("plan-step-preview");
          previewSpan.textContent = `Step ${index + 1}: ${step.description}`;
          headerDiv.appendChild(previewSpan);

          const collapseButton = document.createElement("button");
          collapseButton.classList.add("collapse-button");
          collapseButton.textContent = isCollapsed ? "▼" : "▲";
          headerDiv.appendChild(collapseButton);

          stepDiv.appendChild(headerDiv);

          const contentDiv = document.createElement("div");
          contentDiv.classList.add("plan-step-content");
          contentDiv.classList.toggle("collapsed", isCollapsed);

          const subPromptPre = document.createElement("pre");
          subPromptPre.textContent = step.subPrompt;
          contentDiv.appendChild(subPromptPre);

          const stepMessagesContainer = document.createElement("div");
          stepMessagesContainer.classList.add("step-messages-container");
          stepMessagesContainer.id = `step-messages-${index}`;
          contentDiv.appendChild(stepMessagesContainer);

          stepDiv.appendChild(contentDiv);

          planStepsEl.appendChild(stepDiv);
        });
        scrollToBottom();
      }

      /**
       * Toggles the collapsed state of a plan step.
       * @param {number} stepIndex - The index of the step to toggle.
       */
      function togglePlanStepCollapse(stepIndex) {
        const stepDiv = document.getElementById(`plan-step-${stepIndex}`);
        if (stepDiv) {
          const contentDiv = stepDiv.querySelector(".plan-step-content");
          const collapseButton = stepDiv.querySelector(".collapse-button");
          if (contentDiv && collapseButton) {
            const isCollapsed = contentDiv.classList.toggle("collapsed");
            collapseButton.textContent = isCollapsed ? "▼" : "▲";

            if (
              planState.stepCollapsedStates &&
              planState.stepCollapsedStates.length > stepIndex
            ) {
              planState.stepCollapsedStates[stepIndex] = isCollapsed;
            }
          }
        }
      }

      /**
       * Updates the status icon and class for a specific plan step.
       * @param {number} stepIndex - The index of the step to update.
       * @param {'pending' | 'executing' | 'completed' | 'failed'} status - The new status.
       */
      function updateStepStatus(stepIndex, status) {
        const stepDiv = document.getElementById(`plan-step-${stepIndex}`);
        if (stepDiv) {
          const statusSpan = stepDiv.querySelector(".plan-step-status");
          stepDiv.classList.remove(
            "pending",
            "executing",
            "completed",
            "failed"
          );
          stepDiv.classList.add(status);

          if (statusSpan) {
            switch (status) {
              case "pending":
                statusSpan.textContent = "☐";
                break;
              case "executing":
                statusSpan.innerHTML =
                  '<span class="loader" style="width: 1em; height: 1em; border-width: 2px;"></span>';
                break;
              case "completed":
                statusSpan.textContent = "✅";
                break;
              case "failed":
                statusSpan.textContent = "❌";
                break;
            }
          }
        }
      }

      /**
       * Updates the visibility and state of plan control buttons based on plan state.
       */
      function updatePlanControls() {
        planControlsEl.innerHTML = "";
        planErrorEl.style.display = planState.error ? "block" : "none";
        planErrorEl.textContent = planState.error || "";

        let buttonsHtml = "";
        switch (planState.status) {
          case "idle":
            planContainer.style.display = "none";
            resetPlanButton();
            break;
          case "planning":
            planButton.disabled = true;
            planLoader.style.display = "inline-block";
            planButtonText.textContent = "";
            planContainer.style.display = "block";
            break;
          case "executing":
            buttonsHtml =
              '<button onclick="handlePausePlan()">Pause</button><button onclick="handleStopPlan()">Stop</button>';
            planButton.disabled = true;
            resetPlanButton();
            planContainer.style.display = "block";
            break;
          case "paused":
            buttonsHtml =
              '<button onclick="handleResumePlan()">Resume</button><button onclick="handleStopPlan()">Stop</button>';
            planButton.disabled = true;
            resetPlanButton();
            planContainer.style.display = "block";
            break;
          case "failed":
            buttonsHtml =
              '<button onclick="handleResumePlan()">Resume from Failed Step</button><button onclick="handleStopPlan()">Stop & Reset</button>';
            planButton.disabled = false;
            resetPlanButton();
            planContainer.style.display = "block";
            break;
          case "completed":
            buttonsHtml =
              '<button onclick="handleStopPlan()">Reset Plan</button>';
            planButton.disabled = false;
            resetPlanButton();
            planContainer.style.display = "block";
            break;
        }
        planControlsEl.innerHTML = buttonsHtml;

        if (planState.plan && planState.plan.steps) {
          planState.plan.steps.forEach((_, index) => {
            let status = "pending";
            if (index < planState.currentStepIndex) {
              status = "completed";
            } else if (index === planState.currentStepIndex) {
              status =
                planState.status === "executing"
                  ? "executing"
                  : planState.status === "failed"
                  ? "failed"
                  : "pending";
            } else {
              status = "pending";
            }
            updateStepStatus(index, status);
          });
        }
      }

      window.addEventListener("load", () => {
        userInputEl.value = localStorage.getItem(STORAGE_KEYS.userInput) || "";
        loadState();
        renderChatHistory();
        renderSelectedFiles();

        vscode.postMessage({ command: "requestSystemPrompts" });
        vscode.postMessage({ command: "requestUserPrompts" });
        vscode.postMessage({ command: "requestProviderSettings" });
        vscode.postMessage({ command: "requestAvailableVendors" });
        vscode.postMessage({ command: "requestEnabledTools" });
        vscode.postMessage({ command: "requestCurrentProviderSetting" });

        document.addEventListener("click", function (event) {
          if (
            systemPromptsPopupVisible &&
            !systemPromptsPopupEl.contains(event.target) &&
            event.target !== document.getElementById("systemPromptInput") &&
            event.target !== systemPromptLoadButton
          ) {
            toggleSystemPromptsPopup();
          }
          if (
            userPromptsPopupVisible &&
            !userPromptsPopupEl.contains(event.target) &&
            event.target !== document.getElementById("userInput") &&
            event.target !== userPromptLoadButton
          ) {
            toggleUserPromptsPopup();
          }
          if (
            toolPopupVisible &&
            !toolPopupEl.contains(event.target) &&
            event.target !== addToolButton
          ) {
            toggleToolPopup();
          }
          if (
            providerSettingsPopupVisible &&
            !providerSettingsPopupEl.contains(event.target) &&
            event.target !== providerSettingsButton &&
            !providerFormEl.contains(event.target)
          ) {
            toggleProviderSettingsPopup();
          }
        });

        messagesContainer.addEventListener("click", (event) => {
          const header = event.target.closest(".message-header");
          if (header) {
            const messageEl = header.closest(".message");
            if (
              !event.target.classList.contains("cancel-button") &&
              messageEl &&
              !header.classList.contains("non-collapsible")
            ) {
              const messageId = messageEl.id.replace("message-", "");
              toggleMessageCollapse(messageId, messagesContainer);
            }
          }
        });

        planStepsEl.addEventListener("click", (event) => {
          const header = event.target.closest(".message-header");
          if (header) {
            const messageEl = header.closest(".message");
            const stepMessagesContainer = header.closest(
              ".step-messages-container"
            );
            if (
              !event.target.classList.contains("cancel-button") &&
              messageEl &&
              stepMessagesContainer &&
              !header.classList.contains("non-collapsible")
            ) {
              const messageId = messageEl.id.replace("message-", "");
              toggleMessageCollapse(messageId, stepMessagesContainer);
            }
          }
        });
      });

      userInputEl.addEventListener("input", (e) => {
        updateUserPrompt(e.target.value);
      });

      systemPromptEl.addEventListener("input", (e) => {
        updateSystemPrompt(e.target.value);
      });

      autoRemoveCommentsCheckbox.addEventListener("change", () => {
        vscode.postMessage({
          command: "setAutoRemoveComments",
          checked: autoRemoveCommentsCheckbox.checked,
        });
      });
      autoFormatCheckbox.addEventListener("change", () => {
        vscode.postMessage({
          command: "setAutoFormat",
          checked: autoFormatCheckbox.checked,
        });
      });
      autoFixErrorsCheckbox.addEventListener("change", () => {
        vscode.postMessage({
          command: "setAutoFixErrors",
          checked: autoFixErrorsCheckbox.checked,
        });
      });

      providerNameInput.addEventListener("input", () => {
        providerFormChanged = true;
        updateProviderSettingDebounced();
      });
      providerVendorInput.addEventListener("change", () => {
        providerFormChanged = true;
        updateProviderSettingDebounced();
      });
      providerApiKeyInput.addEventListener("input", () => {
        providerFormChanged = true;
        updateProviderSettingDebounced();
      });
      providerBaseURLInput.addEventListener("input", () => {
        providerFormChanged = true;
        updateProviderSettingDebounced();
      });
      providerModelInput.addEventListener("input", () => {
        providerFormChanged = true;
        updateProviderSettingDebounced();
      });
      providerMaxTokensInput.addEventListener("input", () => {
        providerFormChanged = true;
        updateProviderSettingDebounced();
      });
      providerTemperatureInput.addEventListener("input", () => {
        providerFormChanged = true;
        updateProviderSettingDebounced();
      });

      window.addEventListener("message", (event) => {
        const message = event.data;

        if (message.command === "log") {
          const { id, parentId, message: taskLog } = message;

          let targetContainer = messagesContainer;
          let parentMessageEl = null;

          if (parentId) {
            parentMessageEl = messagesContainer.querySelector(
              `#message-${parentId}`
            );

            if (!parentMessageEl) {
              const planSteps = planStepsEl.querySelectorAll(".plan-step");
              for (const stepDiv of planSteps) {
                const stepMessagesContainer = stepDiv.querySelector(
                  ".step-messages-container"
                );
                if (stepMessagesContainer) {
                  parentMessageEl = stepMessagesContainer.querySelector(
                    `#message-${parentId}`
                  );
                  if (parentMessageEl) {
                    targetContainer = stepMessagesContainer;
                    break;
                  }
                }
              }
            }

            if (parentMessageEl) {
              let childMessagesContainer = parentMessageEl.querySelector(
                ".child-messages-container"
              );
              if (!childMessagesContainer) {
                childMessagesContainer = document.createElement("div");
                childMessagesContainer.classList.add(
                  "child-messages-container"
                );
                const messageBodyContent = parentMessageEl.querySelector(
                  ".message-body-content"
                );
                if (messageBodyContent) {
                  messageBodyContent.after(childMessagesContainer);
                } else {
                  const collapsibleContent = parentMessageEl.querySelector(
                    ".collapsible-content"
                  );
                  if (collapsibleContent) {
                    collapsibleContent.appendChild(childMessagesContainer);
                  } else {
                    parentMessageEl.appendChild(childMessagesContainer);
                  }
                }
              }
              childMessagesContainer.style.display = "";
              targetContainer = childMessagesContainer;
            } else {
              const parentStepEl = document.getElementById(parentId);
              if (parentStepEl) {
                targetContainer =
                  parentStepEl.querySelector(".step-messages-container") ||
                  messagesContainer;
              } else {
                console.warn(
                  `Log message ${id} received with unknown parentId: ${parentId}`
                );
                targetContainer = messagesContainer;
              }
            }
          }

          const existingEl = targetContainer.querySelector(`#message-${id}`);

          if (existingEl) {
            updateMessageElement(
              id,
              {
                type: taskLog.type,
                summary: taskLog.summary,
                detail: taskLog.detail,
                progress: taskLog.progress,
              },
              targetContainer
            );
          } else {
            renderMessage(
              {
                id,
                type: taskLog.type,
                summary: taskLog.summary,
                detail: taskLog.detail,
                progress: taskLog.progress,
                isCollapsed: [
                  "prompt",
                  "tool",
                  "log",
                  "info",
                  "warning",
                  "error",
                ].includes(taskLog.type || "log"),
              },
              targetContainer
            );
          }

          if (parentMessageEl) {
            updateMessageCollapsibility(parentMessageEl);
          }

          scrollToBottom();
          return;
        }

        switch (message.command) {
          case "receiveMessage":
            const newMessageId = message.messageId || Date.now().toString();
            chatHistory.push({
              id: newMessageId,
              detail: message.detail || message.text || "",
              summary:
                message.summary ||
                (message.detail || message.text || "").split("\\n")[0],
              sender: message.sender,
              messageType:
                message.messageType ||
                (message.sender === "user" ? "user" : "assistant"),
              isCollapsed:
                message.isCollapsed ??
                ["prompt", "tool", "log", "info", "warning", "error"].includes(
                  message.messageType || "log"
                ),
            });
            saveState();

            const addedMsg = chatHistory[chatHistory.length - 1];
            renderMessage({
              id: addedMsg.id,
              type: addedMsg.messageType,
              summary: addedMsg.summary,
              detail: addedMsg.detail,
              isCollapsed: addedMsg.isCollapsed,
            });
            scrollToBottom();
            break;
          case "updateMessage":
            updateMainChatMessageHistory(
              message.messageId,
              message.detail || message.text || "",
              message.summary,
              message.sender,
              message.messageType
            );
            updateMessageElement(message.messageId, {
              type: message.messageType,
              summary: message.summary,
              detail: message.detail || message.text || "",
            });
            scrollToBottom();
            break;
          case "endMessage":
            resetSendButton();
            updateMainChatMessageHistory(
              message.messageId,
              message.detail || message.text || "",
              message.summary,
              message.sender,
              message.messageType
            );
            scrollToBottom();
            break;
          case "logMessage":
            const newLogMessageId = message.messageId || Date.now().toString();
            chatHistory.push({
              id: newLogMessageId,
              detail: message.detail || message.text || "",
              summary:
                message.summary ||
                (message.detail || message.text || "").split("\\n")[0],
              sender: "log",
              messageType: message.messageType || "log",
              isCollapsed: message.isCollapsed ?? true,
            });
            saveState();

            const addedLogMsg = chatHistory[chatHistory.length - 1];
            renderMessage({
              id: addedLogMsg.id,
              type: addedLogMsg.messageType,
              summary: addedLogMsg.summary,
              detail: addedLogMsg.detail,
              isCollapsed: addedLogMsg.isCollapsed,
            });
            scrollToBottom();
            break;
          case "clearMessages":
            clearChatHistory();
            break;
          case "setOpenFiles":
            openFiles = message.files;
            saveState();
            renderSelectedFiles();
            break;
          case "startLoading":
            renderMessage({
              id: message.messageId,
              type: "loading",
              summary: message.summary || "Loading...",
              detail: message.detail || "Loading...",
              progress: 0,
              isCollapsed: false,
            });
            scrollToBottom();
            break;
          case "addFilesFromDialog":
            addFiles(message.filePaths);
            break;
          case "systemPromptsList":
            systemPrompts = message.prompts;
            renderSystemPromptsList();
            break;
          case "userPromptsList":
            userPrompts = message.prompts;
            renderUserPromptsList();
            break;
          case "providerSettingsList":
            providerSettingsList = message.providerSettingsList;
            renderProviderSettingsPopupList();
            break;
          case "initPrompts":
            currentSystemPrompt = message.systemPrompt || "";
            currentUserPrompt = message.userPrompt || "";
            systemPrompts = message.systemPrompts || [];
            userPrompts = message.userPrompts || [];
            availableTools = message.availableTools || [];
            enabledTools = message.enabledTools || [];
            currentProviderSetting = message.currentProviderSetting;
            availableVendors = message.availableVendors || [];
            autoRemoveComments = message.autoRemoveComments ?? true;
            autoFormat = message.autoFormat ?? true;
            autoFixErrors = message.autoFixErrors ?? true;
            planState = message.planState;

            systemPromptEl.value = currentSystemPrompt;
            userInputEl.value = currentUserPrompt;
            autoRemoveCommentsCheckbox.checked = autoRemoveComments;
            autoFormatCheckbox.checked = autoFormat;
            autoFixErrorsCheckbox.checked = autoFixErrors;

            renderSystemPromptsList();
            renderUserPromptsList();
            renderEnabledTools();
            renderSelectedProvider();
            renderProviderSettingsPopupList();
            renderVendorDropdown();
            renderSelectedFiles();
            renderChatHistory();

            if (planState && planState.plan) {
              renderPlan(planState.plan);
            }
            updatePlanControls();

            break;
          case "updateEnabledTools":
            enabledTools = message.enabledTools;
            renderEnabledTools();
            break;
          case "providerSettingsUpdated":
            vscode.postMessage({ command: "requestProviderSettings" });
            break;
          case "availableVendors":
            availableVendors = message.availableVendors;
            renderVendorDropdown();
            break;
          case "sendEnabledTools":
            enabledTools = message.enabledTools;
            renderEnabledTools();
            break;
          case "sendCurrentProviderSetting":
            currentProviderSetting = message.currentProviderSetting;
            renderSelectedProvider();
            break;

          case "displayPlan":
            planState.stepCollapsedStates = Array(
              message.plan.steps.length
            ).fill(true);
            renderPlan(message.plan);
            break;
          case "updateStepStatus":
            updateStepStatus(message.stepIndex, message.status);
            break;
          case "updatePlanState":
            const oldPlan = planState.plan;
            planState = message.planState;
            if (
              oldPlan &&
              planState.plan &&
              oldPlan.steps.length === planState.plan.steps.length
            ) {
            } else if (planState.plan) {
              planState.stepCollapsedStates = Array(
                planState.plan.steps.length
              ).fill(true);
              renderPlan(planState.plan);
            } else {
              planStepsEl.innerHTML = "";
              planGoalEl.textContent = "AI Plan:";
              planContainer.style.display = "none";
              planState.stepCollapsedStates = [];
            }
            updatePlanControls();
            if (planState.plan && planState.plan.steps) {
              planState.plan.steps.forEach((_, index) => {
                let status = "pending";
                if (index < planState.currentStepIndex) {
                  status = "completed";
                } else if (index === planState.currentStepIndex) {
                  status =
                    planState.status === "executing"
                      ? "executing"
                      : planState.status === "failed"
                      ? "failed"
                      : "pending";
                } else {
                  status = "pending";
                }
                updateStepStatus(index, status);
              });
            }
            break;

          default:
            console.warn("Unknown command:", message.command);
        }
      });

      window.handleSendMessage = handleSendMessage;
      window.handlePlanAndExecute = handlePlanAndExecute;
      window.handlePausePlan = handlePausePlan;
      window.handleResumePlan = handleResumePlan;
      window.handleStopPlan = handleStopPlan;
      window.handleCancelTask = handleCancelTask;
      window.clearChatHistory = clearChatHistory;
      window.addFilesDialog = addFilesDialog;
      window.allowDrop = allowDrop;
      window.dropHandler = dropHandler;
      window.toggleSystemPromptsPopup = toggleSystemPromptsPopup;
      window.toggleUserPromptsPopup = toggleUserPromptsPopup;
      window.toggleToolPopup = toggleToolPopup;
      window.toggleProviderSettingsPopup = toggleProviderSettingsPopup;
      window.addSystemPromptToLibrary = addSystemPromptToLibrary;
      window.addUserPromptToLibrary = addUserPromptToLibrary;
      window.deleteSystemPrompt = deleteSystemPrompt;
      window.deleteUserPrompt = deleteUserPrompt;
      window.deleteProviderSetting = deleteProviderSetting;
      window.insertSystemPrompt = insertSystemPrompt;
      window.insertUserPrompt = insertUserPrompt;
      window.enableTool = enableTool;
      window.disableTool = disableTool;
      window.selectProviderSetting = selectProviderSetting;
      window.loadProviderSettingToForm = loadProviderSettingToForm;
      window.handleAddProviderButton = handleAddProviderButton;
      window.handleDuplicateProviderSetting = handleDuplicateProviderSetting;
      window.handleCancelProviderSettings = handleCancelProviderSettings;
      window.clearProviderFormErrors = clearProviderFormErrors;
      window.handleSaveProviderSettings = handleSaveProviderSettings;
      window.toggleMessageCollapse = toggleMessageCollapse;
      window.handleRemoveComments = handleRemoveComments;
      window.handleFormat = handleFormat;
      window.handleFixErrors = handleFixErrors;
      window.handleCommitFiles = handleCommitFiles;
      window.updateStepStatus = updateStepStatus;
      window.togglePlanStepCollapse = togglePlanStepCollapse;
      window.handleTestTask = handleTestTask;
      window.handleTestMultiTask = handleTestMultiTask;
      window.handleTestSerialTask = handleTestSerialTask;
    </script>
  </body>
</html>
